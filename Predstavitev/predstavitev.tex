\documentclass{beamer}
\usepackage[utf8]{inputenc} % ÄąË‡umniki
\usepackage[slovene]{babel} % preklopimo na slovenÄąË‡Ă„Ĺ¤ino
\usepackage{amsmath}
\usepackage{amsfonts}
%\usepackage{theorem}
\usepackage{amsthm}
\usepackage{ wasysym }

\usetheme{Warsaw}

\useoutertheme{infolines}
\author[Sintaktična sladkorčka]{Tomaž Stepišnik Perdih\\  Matej Petković}

%\institute[]{FMF}
\title{Izbire}
\date{{22. januar 2015}}
%\institute[]{}

\newtheorem{defin}{Definicija}
\newtheorem{vpr}{Vprašanji}
\newtheorem{odg}{Odgovora}
\newtheorem{dok}{Dokaz}
\newtheorem{posl}{Posledica}
\newtheorem{koda}{Minuta za Haskell}
\newtheorem{prim}{Primer}
\def\Rn{\mathbb{R}^n}
\def\izo{\approx}
\def\eps{\varepsilon}
\def\obs{\exists}
\def\fora{\forall}
\newcommand{\sgn}{\operatorname{sgn}}
\newcommand{\df}{\operatorname{df}}
\newcommand{\argmin}{\operatorname{argmin}}
\newcommand{\argmax}{\operatorname{argmax}}

\begin{document}

\begin{frame}
\titlepage 
\end{frame}

\begin{frame}{Uvodni pojmi}
Imejmo neprazno množico $A$, v kateri so elementi tipa \texttt{a}  in množico logičnih vrednosti $R =  \{ \texttt{true}, \texttt{false}\} $. Definiramo lahko
\begin{itemize}
\item predikate\; $p$\texttt{ :: a -> r}
\item kvantifikatorje\; $\phi$\texttt{ :: (a -> r) -> r}
\item izbire $\varepsilon$\texttt{ :: (a -> r) -> a}
\end{itemize}



\begin{prim}
Naj bo $A = \{1,2,3,4\}$, $\phi = \exists_A$, $p_1 = n \to n > 3$ in $p_2 = n\to n > 4$. Potem je
$$\phi(p_1) = \text{true}\quad\varepsilon (p_1) = 4\quad\text{in}\quad\phi(p_2) = \text{false}\quad\varepsilon (p_2) = \text{?!}$$
\end{prim}

\end{frame}

\begin{frame}{Izbira natančneje}
\begin{defin}
Imejmo neprazno množico $A$. Funkcija $\eps: p \to a_p\in A$ je izbira, če za vsak predikat $p$ velja
$$\left(\obs a\in A. p(a)\right) \Longrightarrow p(a_p)\text{.}$$
\end{defin}
V resnici velja $\left(\obs a\in A. p(a)\right) = p(a_p)$.
\pause
\begin{prim}
Naj bo $A = \{1,2,3,4\}$ in $\phi = \exists_A$. Potem je s predpisom
$$\eps (p) =
\begin{cases}
\min \{ n \in A \mid p(A) \} ;& \phi(p)\\
\hphantom{oooooooooioooo}1\, ;& sicer
\end{cases}
$$
definirana izbira na množici $A$. Torej je $\eps (n \to n > 4) = 1$.
\end{prim}

\end{frame}

\begin{frame}[fragile]{Izbira splošneje}%[fragile] zaradi verbatima
\begin{defin}
Imejmo neprazno množico $A$ in kvantifikator $\phi$ na njej. Funkcija $\eps: p \to a_p\in A$ je izbira, če za vsak predikat $p$ velja
$$\phi (p) \Longleftrightarrow p(a_p)\text{.}$$
\end{defin}

Izbira $\eps$ vrne za dani predikat $p$ zgolj kandidata $a_p$ iz množice $A$, za katerega velja $p(a_p)$.
\pause
\begin{koda}
\begin{verbatim}
preveri e = \p -> p (e p)
\end{verbatim}
\end{koda}
Funkcija \texttt{preveri} preizkusi kandidata. Opazimo, da preslika izbiro v kvantifikator, ki ji pripada. Obratna smer je težja!
\end{frame}

\begin{frame}{Križci in krožci}
Bine in Bane igrata križce in krožce. Označimo z $A_n$ množico možnih potez pred $n$-to potezo, $1\leq n\leq 9$.
Označimo Binetove poteze z $x_i$, Banetove pa z $y_i$. Denimo, da začne Bine.  Zanima ga, ali velja
$$\obs x_1\in A_1.\fora y_2 \in A_2. \obs x_3\in A_3.\fora y_4 \cdots \obs x_9 \in A_9. \operatorname{zmaga}_\text{BINE}(x_1,y_2,\dots, y_8,x_9) \text{,}$$
\pause
kar lahko, če Binetovo zmago označimo z $1$, Banetovo z $-1$ ter izenačenje z $0$, prepišemo v

$$\max_{x_1}. \min_{y_2}. \cdots \max_{x_9}. \operatorname{vrednost}(x_1, y_2,\dots, y_8, x_9) = 1\text{.}$$

\begin{prim}
Tudi $\min$ in $\max$ sta kvantifikatorja tipa \texttt{(poteze -> R) -> R} za $R = \{-1, 0, 1\}$.
\end{prim}

\end{frame}

\begin{frame}
\begin{vpr}
	\begin{itemize}
	\item Kako se končajo križci in krožci (ter podobne igre), če oba igralca igrata optimalno? (kvantifikatorji)
	\item Kakšno je optimalno zaporedje potez? (izbire)
	\end{itemize}
\end{vpr}
\pause
\begin{odg}
	\begin{itemize}
	\item Izračunamo $$\max_{x_1}\min_{y_2}\cdots \max_{x_9}\;\operatorname{vrednost}(x_1, y_2,\dots, x_9)$$
	\item Za kvantifikatorja $\min$ in $\max$ najdemo pripadajoči izbiri $\argmin$ in $\argmax$. Potem vseh devet izbir
	za posamezno potezo zdužimo v izbiro zaporedja potez.
	\end{itemize}
\end{odg}

\end{frame}

\begin{frame}[fragile]{Združevanje izbir}%[fragile] zaradi verbatima
Združevanje izbir se malo zaplete, ker je vsaka poteza odvisna od vseh prejšnjih (tudi prva \smiley).
Označimo tip potez s \texttt{pot} in tip elementov naše množice $R$ z \texttt{r}.
\begin{koda}[produkt izbir $\otimes$]
\begin{verbatim}
type J x = (x -> r) -> x

otimes :: J pot -> (pot -> J [pot]) -> J [pot]
otimes e0 e1 p = a0 : a1
    where
        a0 = e0(\x0 -> preveri (e1 x0) (\x1 -> p (x0 : x1)))
        a1 = e1 a0 (\x1 -> p(a0 : x1))
\end{verbatim}
\end{koda}

\end{frame}


\begin{frame}[fragile]{Združevanje izbir}
\begin{koda}[produkt izbir $\bigotimes$]
\begin{verbatim}
bigotimes :: [J r pot] -> J r [pot]
bigotimes [] = \p -> []
bigotimes (e : es) = e `otimes` bigotimes es
\end{verbatim}
\end{koda}
\end{frame}











\end{document}